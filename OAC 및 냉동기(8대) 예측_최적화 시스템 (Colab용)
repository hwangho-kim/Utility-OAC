{"cells":[{"cell_type":"code","source":"import pandas as pd\nimport numpy as np\nimport PsychroLib as psy # 습공기 계산 라이브러리\nfrom sklearn.ensemble import RandomForestRegressor\nfrom sklearn.model_selection import train_test_split # 실제 학습 시 사용\nfrom sklearn.preprocessing import PolynomialFeatures # COP 모델용 다항 피처 생성\nfrom sklearn.linear_model import LinearRegression # COP 모델용 선형 회귀\nfrom itertools import combinations # 냉동기 조합 생성용\nimport joblib # 모델 저장/로드용 (Colab에서는 파일 경로 주의)\nimport time # 실행 시간 측정용\n\n# --- 0. 기본 설정 및 유틸리티 함수 ---\npsy.SetUnitSystem(psy.SI) # 습공기 라이브러리 SI 단위계 설정\nNUM_OACS = 14 # OAC 대수\nNUM_CHILLERS = 8 # 냉동기 대수 변경\nSTANDARD_PRESSURE_PA = 101325.0 # 표준 대기압 (Pa)\nWATER_CP_KJ_KG_K = 4.186 # 물의 비열 (kJ/kg.K)\nRT_TO_KW = 3.51685 # 1 Refrigeration Ton to kW\n\n# OAC별 공기 질량 유량 (kg/s) - 실제로는 추정 또는 측정값 사용\n# 예시로 모든 OAC가 동일한 풍량을 갖는다고 가정 (2 kg/s => 약 6000 CMH)\nOAC_AIR_FLOW_KG_S = {oac_id: 2.0 for oac_id in range(1, NUM_OACS + 1)}\n\n# 냉동기 사양 (8대 가정, 용량 및 최소/최대 부하율은 예시)\nCHILLER_SPECS = {\n    1: {'capacity_rt': 150, 'min_load_pct': 0.25, 'max_load_pct': 1.0},\n    2: {'capacity_rt': 150, 'min_load_pct': 0.25, 'max_load_pct': 1.0},\n    3: {'capacity_rt': 200, 'min_load_pct': 0.20, 'max_load_pct': 1.0},\n    4: {'capacity_rt': 200, 'min_load_pct': 0.20, 'max_load_pct': 1.0},\n    5: {'capacity_rt': 250, 'min_load_pct': 0.20, 'max_load_pct': 1.0},\n    6: {'capacity_rt': 250, 'min_load_pct': 0.20, 'max_load_pct': 1.0},\n    7: {'capacity_rt': 300, 'min_load_pct': 0.15, 'max_load_pct': 1.0},\n    8: {'capacity_rt': 300, 'min_load_pct': 0.15, 'max_load_pct': 1.0},\n}\n\ndef get_air_properties(temp_c, rel_hum_percent, pressure_pa=STANDARD_PRESSURE_PA):\n    \"\"\"주어진 건구온도, 상대습도, 대기압에서 습공기 물성치 계산\"\"\"\n    rh = rel_hum_percent / 100.0\n    rh = np.clip(rh, 0.001, 0.999) # PsychroLib 입력 범위 보정\n\n    try:\n        hum_ratio = psy.GetHumRatioFromRelHum(temp_c, rh, pressure_pa)\n        enthalpy_j_kg = psy.GetMoistAirEnthalpy(temp_c, hum_ratio)\n        specific_vol_m3_kg = psy.GetMoistAirVolume(temp_c, hum_ratio, pressure_pa)\n        return {\n            \"humidity_ratio_kg_kg\": hum_ratio,\n            \"enthalpy_kj_kg\": enthalpy_j_kg / 1000.0,\n            \"specific_volume_m3_kg\": specific_vol_m3_kg\n        }\n    except Exception as e:\n        # print(f\"PsychroLib Error: T={temp_c}, RH={rel_hum_percent} -> {e}\")\n        return {\"humidity_ratio_kg_kg\": np.nan, \"enthalpy_kj_kg\": np.nan, \"specific_volume_m3_kg\": np.nan}\n\ndef generate_final_dummy_data(num_samples=8760, num_oacs=NUM_OACS, chiller_specs_dict=CHILLER_SPECS):\n    \"\"\"엔탈피 관계 및 냉동기 효율 등을 보다 현실적으로 반영한 더미 데이터 생성 (냉동기 8대 반영)\"\"\"\n    data_list = []\n    total_chiller_capacity_rt = sum(spec['capacity_rt'] for spec in chiller_specs_dict.values())\n\n    for i in range(num_samples):\n        timestamp = pd.Timestamp('2024-01-01') + pd.Timedelta(hours=i)\n        outside_temp_c = 15 + 10 * np.sin(2 * np.pi * i / (24 * 30)) + 5 * np.sin(2 * np.pi * i / 24)\n        outside_rel_hum = 60 + 20 * np.sin(2 * np.pi * i / (24*15))\n        outside_props = get_air_properties(outside_temp_c, outside_rel_hum)\n        \n        row_data = {\n            'timestamp': timestamp,\n            'outside_temp_c': outside_temp_c,\n            'outside_rel_hum': outside_rel_hum,\n            'outside_enthalpy_kj_kg': outside_props['enthalpy_kj_kg'],\n            'outside_humidity_ratio_kg_kg': outside_props['humidity_ratio_kg_kg'],\n        }\n\n        total_oac_cooling_load_kw_actual = 0\n        for oac_id in range(1, num_oacs + 1):\n            fab_target_temp_c = 22.0\n            fab_target_rel_hum = 45.0\n            fab_target_props = get_air_properties(fab_target_temp_c, fab_target_rel_hum)\n            fab_current_temp_c = fab_target_temp_c + np.random.normal(0, 0.2)\n            fab_current_rel_hum = fab_target_rel_hum + np.random.normal(0, 1.0)\n            fab_current_props = get_air_properties(fab_current_temp_c, fab_current_rel_hum)\n\n            row_data[f'oac_{oac_id}_fab_enthalpy_kj_kg_target'] = fab_target_props['enthalpy_kj_kg']\n            row_data[f'oac_{oac_id}_fab_enthalpy_kj_kg_current'] = fab_current_props['enthalpy_kj_kg']\n            row_data[f'oac_{oac_id}_fab_hr_kg_kg_current'] = fab_current_props['humidity_ratio_kg_kg']\n            \n            oac_inlet_enthalpy = 0.3 * outside_props['enthalpy_kj_kg'] + 0.7 * fab_current_props['enthalpy_kj_kg']\n            row_data[f'oac_{oac_id}_inlet_enthalpy_kj_kg'] = oac_inlet_enthalpy\n            \n            delta_h_cooling_kj_kg_target = max(0, oac_inlet_enthalpy - fab_target_props['enthalpy_kj_kg'])\n            row_data[f'oac_{oac_id}_delta_h_kj_kg_target'] = delta_h_cooling_kj_kg_target\n            \n            max_delta_h_achievable = 20.0 \n            coil_opening = np.clip(delta_h_cooling_kj_kg_target / max_delta_h_achievable, 0, 1) * 100\n            coil_opening = np.clip(coil_opening + np.random.normal(0,5), 0, 100)\n            row_data[f'oac_{oac_id}_cooling_coil_opening_actual'] = coil_opening\n            \n            oac_actual_load_kw = delta_h_cooling_kj_kg_target * OAC_AIR_FLOW_KG_S[oac_id] * (coil_opening / 100.0 + np.random.uniform(-0.05,0.05))\n            oac_actual_load_kw = max(0, oac_actual_load_kw)\n            row_data[f'oac_{oac_id}_actual_cooling_load_kw'] = oac_actual_load_kw\n            total_oac_cooling_load_kw_actual += oac_actual_load_kw\n        \n        row_data['total_oac_actual_cooling_load_kw'] = total_oac_cooling_load_kw_actual\n        row_data['main_chw_dp_bar_actual'] = np.clip(1.8 + total_oac_cooling_load_kw_actual / (sum(OAC_AIR_FLOW_KG_S.values())*10) , 1.0, 2.5)\n        row_data['main_chw_dpv_opening_actual'] = np.clip(80 - (row_data['main_chw_dp_bar_actual'] - 1.5) * 30, 10, 90)\n        row_data['main_chw_supply_temp_c_actual'] = 7.0 + np.random.uniform(-0.2, 0.2)\n        row_data['main_chw_return_temp_c_actual'] = row_data['main_chw_supply_temp_c_actual'] + \\\n                                                total_oac_cooling_load_kw_actual / (sum(OAC_AIR_FLOW_KG_S.values()) * 1.1 * WATER_CP_KJ_KG_K )\n        \n        chiller_total_load_kw_actual = total_oac_cooling_load_kw_actual * 1.05 # 배관 손실 5%\n        chiller_total_load_rt_actual = chiller_total_load_kw_actual / RT_TO_KW\n        row_data['chiller_total_load_rt_actual'] = chiller_total_load_rt_actual\n        \n        # 냉동기 가동 대수 결정 (8대용 단순 규칙)\n        num_chillers_to_run = 0\n        if chiller_total_load_rt_actual > 0:\n            # 총 용량 대비 부하율에 따라 가동 대수 결정 (예시)\n            load_vs_total_capacity_ratio = chiller_total_load_rt_actual / total_chiller_capacity_rt\n            if load_vs_total_capacity_ratio < 0.10: num_chillers_to_run = 1\n            elif load_vs_total_capacity_ratio < 0.20: num_chillers_to_run = 2\n            elif load_vs_total_capacity_ratio < 0.35: num_chillers_to_run = 3\n            elif load_vs_total_capacity_ratio < 0.50: num_chillers_to_run = 4\n            elif load_vs_total_capacity_ratio < 0.65: num_chillers_to_run = 5\n            elif load_vs_total_capacity_ratio < 0.80: num_chillers_to_run = 6\n            elif load_vs_total_capacity_ratio < 0.90: num_chillers_to_run = 7\n            else: num_chillers_to_run = 8\n        num_chillers_to_run = min(num_chillers_to_run, len(chiller_specs_dict))\n\n\n        active_chillers_ids = list(chiller_specs_dict.keys())[:num_chillers_to_run] # ID 순서대로 가동\n        current_active_capacity_rt = sum(chiller_specs_dict[cid]['capacity_rt'] for cid in active_chillers_ids) if active_chillers_ids else 1\n\n        for chiller_id, spec in chiller_specs_dict.items():\n            if chiller_id in active_chillers_ids:\n                chiller_load_rt = (chiller_total_load_rt_actual) * (spec['capacity_rt'] / current_active_capacity_rt)\n                load_ratio = chiller_load_rt / spec['capacity_rt']\n                load_ratio = np.clip(load_ratio, spec['min_load_pct'] if chiller_load_rt > 0 else 0, spec['max_load_pct'])\n                \n                base_cop = 5.5 \n                cop = base_cop - 10 * (load_ratio - 0.75)**2 + np.random.uniform(-0.2,0.2)\n                cop = np.clip(cop, 2.0, 6.0) \n                if chiller_load_rt == 0: cop = 0\n                power_kw = (chiller_load_rt * RT_TO_KW) / cop if cop > 0 else 0\n                \n                row_data[f'chiller_{chiller_id}_load_rt_actual'] = chiller_load_rt\n                row_data[f'chiller_{chiller_id}_power_kw_actual'] = power_kw\n                row_data[f'chiller_{chiller_id}_cop_actual'] = cop\n            else:\n                row_data[f'chiller_{chiller_id}_load_rt_actual'] = 0\n                row_data[f'chiller_{chiller_id}_power_kw_actual'] = 0\n                row_data[f'chiller_{chiller_id}_cop_actual'] = 0\n        data_list.append(row_data)\n    return pd.DataFrame(data_list)\n\ndef train_all_models(df_history, num_oacs=NUM_OACS, chiller_specs=CHILLER_SPECS):\n    \"\"\"모든 예측 모델들을 학습하고 딕셔너리 형태로 반환\"\"\"\n    models = {}\n    df = df_history.dropna().copy()\n\n    if df.empty:\n        print(\"Warning: DataFrame is empty after dropping NaNs. Cannot train models.\")\n        return None\n\n    # Phase 1a: OAC 목표 $\\Delta h$ 예측 모델\n    models['oac_delta_h_target'] = {}\n    for oac_id in range(1, num_oacs + 1):\n        # 필요한 컬럼들이 모두 존재하는지 확인\n        delta_h_features = [\n            'outside_enthalpy_kj_kg', 'outside_humidity_ratio_kg_kg',\n            f'oac_{oac_id}_fab_enthalpy_kj_kg_current', f'oac_{oac_id}_fab_hr_kg_kg_current',\n            f'oac_{oac_id}_fab_enthalpy_kj_kg_target',\n            f'oac_{oac_id}_inlet_enthalpy_kj_kg'\n        ]\n        delta_h_target_col = f'oac_{oac_id}_delta_h_kj_kg_target'\n        \n        if not all(col in df.columns for col in delta_h_features + [delta_h_target_col]):\n            print(f\"Warning: Missing columns for OAC {oac_id} delta_h model. Skipping.\")\n            continue\n\n        X = df[delta_h_features]\n        y = df[delta_h_target_col]\n        if X.empty or y.empty:\n            print(f\"Warning: Empty data for OAC {oac_id} delta_h model. Skipping.\")\n            continue\n        model = RandomForestRegressor(n_estimators=30, random_state=42, n_jobs=-1, max_depth=8, min_samples_leaf=10)\n        model.fit(X, y)\n        models['oac_delta_h_target'][oac_id] = model\n\n    # Phase 1b: $\\Delta h$ -> 코일 개도율 예측 모델\n    models['oac_coil_opening_from_delta_h'] = {}\n    for oac_id in range(1, num_oacs + 1):\n        coil_features = [\n            f'oac_{oac_id}_delta_h_kj_kg_target',\n            f'oac_{oac_id}_inlet_enthalpy_kj_kg',\n            'main_chw_supply_temp_c_actual'\n        ]\n        coil_target_col = f'oac_{oac_id}_cooling_coil_opening_actual'\n\n        if not all(col in df.columns for col in coil_features + [coil_target_col]):\n            print(f\"Warning: Missing columns for OAC {oac_id} coil opening model. Skipping.\")\n            continue\n        \n        X = df[coil_features]\n        y = df[coil_target_col]\n        if X.empty or y.empty:\n            print(f\"Warning: Empty data for OAC {oac_id} coil opening model. Skipping.\")\n            continue\n        model = RandomForestRegressor(n_estimators=30, random_state=42, n_jobs=-1, max_depth=8, min_samples_leaf=10)\n        model.fit(X, y)\n        models['oac_coil_opening_from_delta_h'][oac_id] = model\n\n    # Phase 2b: 메인 차압 및 DPV 개도율 예측 모델\n    dp_features_cols = ['total_oac_actual_cooling_load_kw', 'main_chw_supply_temp_c_actual']\n    if all(col in df.columns for col in dp_features_cols + ['main_chw_dp_bar_actual', 'main_chw_dpv_opening_actual']):\n        models['main_chw_dp_bar'] = RandomForestRegressor(n_estimators=30, random_state=42).fit(df[dp_features_cols], df['main_chw_dp_bar_actual'])\n        models['main_chw_dpv_opening'] = RandomForestRegressor(n_estimators=30, random_state=42).fit(df[dp_features_cols], df['main_chw_dpv_opening_actual'])\n    else:\n        print(\"Warning: Missing columns for DP/DPV models. Skipping.\")\n\n    # Phase 3: 냉동기 총 부하(RT) 예측 모델\n    chiller_load_features_cols = ['total_oac_actual_cooling_load_kw', 'main_chw_return_temp_c_actual']\n    if all(col in df.columns for col in chiller_load_features_cols + ['chiller_total_load_rt_actual']):\n        models['chiller_total_load_rt'] = RandomForestRegressor(n_estimators=30, random_state=42).fit(df[chiller_load_features_cols], df['chiller_total_load_rt_actual'])\n    else:\n        print(\"Warning: Missing columns for chiller total load model. Skipping.\")\n\n    # Phase 5용: 냉동기 COP 예측 모델\n    models['chiller_cop_models'] = {}\n    for chiller_id, spec in chiller_specs.items():\n        load_ratio_col = f'chiller_{chiller_id}_load_ratio_actual'\n        load_rt_col = f'chiller_{chiller_id}_load_rt_actual'\n        cop_col = f'chiller_{chiller_id}_cop_actual'\n\n        if not all(col in df.columns for col in [load_rt_col, cop_col]):\n            print(f\"Warning: Missing columns for Chiller {chiller_id} COP model. Skipping.\")\n            models['chiller_cop_models'][chiller_id] = None\n            continue\n            \n        df[load_ratio_col] = df[load_rt_col] / spec['capacity_rt']\n        cop_df = df[df[load_rt_col] > 0].copy() # 운전 중 데이터만 사용\n\n        if not cop_df.empty and load_ratio_col in cop_df.columns and cop_col in cop_df.columns:\n            X_cop = cop_df[[load_ratio_col]]\n            y_cop = cop_df[cop_col]\n            \n            poly = PolynomialFeatures(degree=2, include_bias=False)\n            X_cop_poly = poly.fit_transform(X_cop)\n            cop_model = LinearRegression()\n            cop_model.fit(X_cop_poly, y_cop)\n            models['chiller_cop_models'][chiller_id] = {'model': cop_model, 'poly_features': poly}\n        else:\n            print(f\"Warning: No valid operational data for Chiller {chiller_id} COP model. Skipping.\")\n            models['chiller_cop_models'][chiller_id] = None\n            \n    print(\"모델 학습 완료.\")\n    return models\n\ndef determine_optimal_chiller_operation(predicted_total_chiller_load_rt, chiller_specs, trained_chiller_cop_models):\n    \"\"\"예측된 총 냉동기 부하에 대해 최적의 냉동기 가동 조합 및 전력 소비량 결정\"\"\"\n    start_time = time.time()\n    best_op_info = {\n        \"chiller_ids_on\": [], \"num_on\": 0, \"total_predicted_power_kw\": float('inf'),\n        \"details\": [], \"total_handled_load_rt\": 0, \"message\": \"No valid operation found.\"\n    }\n\n    if predicted_total_chiller_load_rt <= 1e-3: # 매우 작은 부하는 무시\n        best_op_info[\"message\"] = \"No significant load required, all chillers off.\"\n        best_op_info[\"total_predicted_power_kw\"] = 0\n        return best_op_info\n\n    available_chiller_ids = list(chiller_specs.keys())\n    \n    # 가능한 모든 조합 탐색 (1대부터 최대 N대까지)\n    # 냉동기 수가 많아지면 이 부분의 계산량이 급증합니다 (2^N - 1 조합)\n    num_combinations_evaluated = 0\n    for num_to_operate in range(1, len(available_chiller_ids) + 1):\n        for current_chiller_id_combination in combinations(available_chiller_ids, num_to_operate):\n            num_combinations_evaluated += 1\n            combination_total_capacity_rt = sum(chiller_specs[cid]['capacity_rt'] for cid in current_chiller_id_combination)\n            \n            if combination_total_capacity_rt < predicted_total_chiller_load_rt:\n                continue\n\n            min_total_load_for_combination_rt = sum(\n                chiller_specs[cid]['capacity_rt'] * chiller_specs[cid]['min_load_pct'] for cid in current_chiller_id_combination\n            )\n            if predicted_total_chiller_load_rt < min_total_load_for_combination_rt and predicted_total_chiller_load_rt > 1e-3 :\n                 continue\n            \n            current_combination_power_kw = 0\n            current_combination_details = []\n            final_assigned_total_load_rt_for_combo = 0\n\n            # 부하 배분 (용량 비례)\n            temp_details = []\n            for chiller_id in current_chiller_id_combination:\n                assigned_load_rt = predicted_total_chiller_load_rt * (chiller_specs[chiller_id]['capacity_rt'] / combination_total_capacity_rt)\n                spec = chiller_specs[chiller_id]\n                min_rt = spec['capacity_rt'] * spec['min_load_pct']\n                max_rt = spec['capacity_rt'] * spec['max_load_pct']\n                \n                # 할당된 부하가 해당 냉동기의 운전 범위를 벗어나는지 확인\n                if assigned_load_rt < min_rt and assigned_load_rt > 1e-3 : # 0이 아닌데 최소부하 미만이면\n                    # 이 조합은 부적합할 수 있음 (더 정교한 부하 배분 로직 필요)\n                    # 여기서는 일단 이 냉동기는 최소부하로 운전하고, 나머지가 더 부담하도록 재분배 필요\n                    # 단순화를 위해 이 조합은 건너뛰거나, 페널티를 줄 수 있음\n                    pass # 일단 진행하고 COP 모델이 반영하도록 함\n                \n                assigned_load_rt = np.clip(assigned_load_rt, 0, max_rt) # 최대부하 초과 방지\n                temp_details.append({'id': chiller_id, 'assigned_rt': assigned_load_rt})\n                final_assigned_total_load_rt_for_combo += assigned_load_rt\n\n            # 만약 총 배분된 부하가 요구부하와 크게 다르면 (클리핑 등으로 인해), 이 조합은 부적합\n            if abs(final_assigned_total_load_rt_for_combo - predicted_total_chiller_load_rt) > 0.05 * predicted_total_chiller_load_rt and predicted_total_chiller_load_rt > 1e-3:\n                continue\n\n\n            for detail_item in temp_details: # 재계산된 부하로 COP 및 전력 계산\n                chiller_id = detail_item['id']\n                assigned_load_rt = detail_item['assigned_rt'] # 여기서 최종 배분된 부하 사용\n                \n                spec = chiller_specs[chiller_id]\n                load_ratio = assigned_load_rt / spec['capacity_rt'] if spec['capacity_rt'] > 0 else 0\n                load_ratio = np.clip(load_ratio, 0, 1.0)\n\n                cop_model_dict = trained_chiller_cop_models.get(chiller_id)\n                predicted_cop = 0\n                if cop_model_dict and cop_model_dict['model']:\n                    if load_ratio < spec['min_load_pct'] and assigned_load_rt > 1e-3: # 최소부하 미만 운전 시 COP 급감 가정\n                        predicted_cop = 1.0 # 매우 낮은 COP\n                    elif assigned_load_rt <= 1e-3:\n                        predicted_cop = 0 # 부하 없으면 COP 0\n                    else:\n                        if cop_model_dict['poly_features']:\n                            X_cop_poly = cop_model_dict['poly_features'].transform(np.array([[load_ratio]]))\n                            predicted_cop = cop_model_dict['model'].predict(X_cop_poly)[0]\n                        else:\n                            predicted_cop = cop_model_dict['model'].predict(np.array([[load_ratio]]))[0] # RandomForest 등\n                \n                predicted_cop = np.clip(predicted_cop, 0.5, 10.0) # 비정상 COP 방지\n\n                power_kw = (assigned_load_rt * RT_TO_KW) / predicted_cop if predicted_cop > 0 and assigned_load_rt > 0 else 0\n                current_combination_power_kw += power_kw\n                current_combination_details.append({\n                    \"chiller_id\": chiller_id, \"assigned_load_rt\": round(assigned_load_rt, 2),\n                    \"load_ratio\": round(load_ratio, 3), \"predicted_cop\": round(predicted_cop, 2),\n                    \"predicted_power_kw\": round(power_kw, 2)\n                })\n\n            if current_combination_power_kw < best_op_info[\"total_predicted_power_kw\"]:\n                best_op_info = {\n                    \"chiller_ids_on\": list(current_chiller_id_combination),\n                    \"num_on\": num_to_operate,\n                    \"total_predicted_power_kw\": round(current_combination_power_kw, 2),\n                    \"details\": current_combination_details,\n                    \"total_handled_load_rt\": round(final_assigned_total_load_rt_for_combo,2),\n                    \"message\": \"Optimal combination found.\"\n                }\n    \n    end_time = time.time()\n    print(f\"  Optimal chiller operation determined in {end_time - start_time:.2f}s. Evaluated {num_combinations_evaluated} combinations.\")\n    \n    if best_op_info[\"total_predicted_power_kw\"] == float('inf') and predicted_total_chiller_load_rt > 0:\n         best_op_info[\"message\"] = \"Could not find a combination to meet the load efficiently or within constraints.\"\n    return best_op_info\n\ndef run_complete_cycle_prediction_optimization(current_oac_inlet_conditions,\n                                               current_fab_conditions,\n                                               current_outside_conditions,\n                                               current_chw_conditions,\n                                               trained_models,\n                                               oac_air_flow_kg_s,\n                                               chiller_specs_dict, # 이름 변경\n                                               num_oacs=NUM_OACS\n                                               ):\n    \"\"\"한 사이클의 전체 예측 및 최적화 실행\"\"\"\n    results = {}\n    if trained_models is None:\n        return {\"error\": \"Models not trained.\"}\n\n    # 외기 물성치\n    outside_props = get_air_properties(current_outside_conditions['temp_c'], current_outside_conditions['rel_hum'])\n    if pd.isna(outside_props['enthalpy_kj_kg']): return {\"error\": \"Failed to calculate outside air properties.\"}\n\n    # Phase 1: OAC $\\Delta h$ 및 코일 개도율 예측\n    predicted_oac_delta_h_kj_kg = {}\n    predicted_oac_coil_openings = {}\n    for oac_id in range(1, num_oacs + 1):\n        fab_current_props = get_air_properties(current_fab_conditions[oac_id]['temp_c_current'], current_fab_conditions[oac_id]['rh_current'])\n        fab_target_props = get_air_properties(current_fab_conditions[oac_id]['temp_c_target'], current_fab_conditions[oac_id]['rh_target'])\n        oac_inlet_props = get_air_properties(current_oac_inlet_conditions[oac_id]['temp_c'], current_oac_inlet_conditions[oac_id]['rh'])\n        if any(pd.isna(p['enthalpy_kj_kg']) for p in [fab_current_props, fab_target_props, oac_inlet_props]):\n             return {\"error\": f\"Failed to calculate air properties for OAC {oac_id} or its FAB zone.\"}\n\n        model_delta_h = trained_models['oac_delta_h_target'].get(oac_id)\n        if not model_delta_h: return {\"error\": f\"Delta_h model for OAC {oac_id} not found.\"}\n        \n        features_delta_h_df = pd.DataFrame([{\n            'outside_enthalpy_kj_kg': outside_props['enthalpy_kj_kg'],\n            'outside_humidity_ratio_kg_kg': outside_props['humidity_ratio_kg_kg'],\n            f'oac_{oac_id}_fab_enthalpy_kj_kg_current': fab_current_props['enthalpy_kj_kg'],\n            f'oac_{oac_id}_fab_hr_kg_kg_current': fab_current_props['humidity_ratio_kg_kg'],\n            f'oac_{oac_id}_fab_enthalpy_kj_kg_target': fab_target_props['enthalpy_kj_kg'],\n            f'oac_{oac_id}_inlet_enthalpy_kj_kg': oac_inlet_props['enthalpy_kj_kg']\n        }])[model_delta_h.feature_names_in_]\n        pred_delta_h = model_delta_h.predict(features_delta_h_df)[0]\n        predicted_oac_delta_h_kj_kg[oac_id] = max(0, pred_delta_h)\n\n        model_coil_opening = trained_models['oac_coil_opening_from_delta_h'].get(oac_id)\n        if not model_coil_opening: return {\"error\": f\"Coil opening model for OAC {oac_id} not found.\"}\n        \n        features_coil_opening_df = pd.DataFrame([{\n            f'oac_{oac_id}_delta_h_kj_kg_target': predicted_oac_delta_h_kj_kg[oac_id],\n            f'oac_{oac_id}_inlet_enthalpy_kj_kg': oac_inlet_props['enthalpy_kj_kg'],\n            'main_chw_supply_temp_c_actual': current_chw_conditions['supply_temp_c']\n        }])[model_coil_opening.feature_names_in_]\n        pred_coil_opening = model_coil_opening.predict(features_coil_opening_df)[0]\n        predicted_oac_coil_openings[oac_id] = np.clip(pred_coil_opening, 0, 100)\n    results['oac_coil_opening_pred'] = predicted_oac_coil_openings\n    print(f\"Phase 1: OAC 코일 개도율 예측 완료.\")\n\n    # Phase 2: 총 OAC 냉각 부하(kW) 산출\n    total_predicted_oac_cooling_load_kw = sum(\n        predicted_oac_delta_h_kj_kg[oac_id] * oac_air_flow_kg_s[oac_id] for oac_id in range(1, num_oacs + 1)\n    )\n    total_predicted_oac_cooling_load_kw = max(0, total_predicted_oac_cooling_load_kw)\n    results['total_oac_cooling_load_kw_pred'] = total_predicted_oac_cooling_load_kw\n    print(f\"Phase 2: 총 OAC 냉각 부하 예측: {total_predicted_oac_cooling_load_kw:.2f} kW\")\n\n    # Phase 3: 냉수 시스템 파라미터 예측\n    features_dp_df = pd.DataFrame([{\n        'total_oac_actual_cooling_load_kw': total_predicted_oac_cooling_load_kw, # 학습 시 사용한 컬럼명 일치\n        'main_chw_supply_temp_c_actual': current_chw_conditions['supply_temp_c']\n    }])\n    if 'main_chw_dp_bar' in trained_models and trained_models['main_chw_dp_bar']:\n        model_dp_bar = trained_models['main_chw_dp_bar']\n        results['main_chw_dp_bar_pred'] = model_dp_bar.predict(features_dp_df[model_dp_bar.feature_names_in_])[0]\n    if 'main_chw_dpv_opening' in trained_models and trained_models['main_chw_dpv_opening']:\n        model_dpv_opening = trained_models['main_chw_dpv_opening']\n        results['main_chw_dpv_opening_pred'] = np.clip(model_dpv_opening.predict(features_dp_df[model_dpv_opening.feature_names_in_])[0], 0, 100)\n    print(f\"Phase 3: 냉수 시스템 예측 완료.\")\n\n    # Phase 4: 냉동기 총 부하(RT) 예측\n    features_chiller_load_df = pd.DataFrame([{\n        'total_oac_actual_cooling_load_kw': total_predicted_oac_cooling_load_kw, # 학습 시 사용한 컬럼명 일치\n        'main_chw_return_temp_c_actual': current_chw_conditions['return_temp_c']\n    }])\n    if 'chiller_total_load_rt' in trained_models and trained_models['chiller_total_load_rt']:\n        model_chiller_load = trained_models['chiller_total_load_rt']\n        results['chiller_total_load_rt_pred'] = max(0, model_chiller_load.predict(features_chiller_load_df[model_chiller_load.feature_names_in_])[0])\n    else: # 모델 없으면 OAC 부하 + 손실률로 추정\n        results['chiller_total_load_rt_pred'] = (total_predicted_oac_cooling_load_kw * 1.05) / RT_TO_KW # 5% 손실 가정\n    print(f\"Phase 4: 냉동기 총 부하 예측: {results.get('chiller_total_load_rt_pred', 0):.2f} RT\")\n\n    # Phase 5: 최적 냉동기 운영 결정\n    optimal_chiller_op = determine_optimal_chiller_operation(\n        results.get('chiller_total_load_rt_pred', 0),\n        chiller_specs_dict, # 이름 변경된 파라미터 사용\n        trained_models.get('chiller_cop_models', {})\n    )\n    results['optimal_chiller_operation'] = optimal_chiller_op\n    print(f\"Phase 5: 최적 냉동기 운영 방안 결정 완료.\")\n    if 'details' in optimal_chiller_op and optimal_chiller_op['details']:\n         for detail in optimal_chiller_op['details']:\n            print(f\"  - Chiller {detail['chiller_id']}: Load {detail['assigned_load_rt']} RT, COP {detail['predicted_cop']}, Power {detail['predicted_power_kw']} kW\")\n         print(f\"  Total Power: {optimal_chiller_op.get('total_predicted_power_kw',0)} kW for {optimal_chiller_op.get('total_handled_load_rt',0)} RT\")\n    elif 'message' in optimal_chiller_op:\n        print(f\"  Message: {optimal_chiller_op['message']}\")\n\n\n    return results\n\n# --- 4. 메인 실행 부분 (예시) ---\nif __name__ == '__main__':\n    print(\"### 시스템 초기화 및 모델 학습 시작 ###\")\n    # 가상 과거 데이터 생성 (샘플 수 줄여서 Colab에서 빠르게 테스트)\n    # 실제 운영 시에는 충분한 양의 실제 데이터 사용 필요\n    historical_data = generate_final_dummy_data(num_samples=24*7, chiller_specs_dict=CHILLER_SPECS) # 1주일치 데이터\n    print(f\"가상 과거 데이터 {len(historical_data)}건 생성 완료.\")\n\n    # 모든 모델 학습\n    trained_models = train_all_models(historical_data, NUM_OACS, CHILLER_SPECS)\n    \n    # Colab에서 모델 저장/로드 시 경로 주의\n    # joblib.dump(trained_models, 'trained_chvac_models_colab.pkl')\n    # trained_models = joblib.load('trained_chvac_models_colab.pkl')\n\n    print(\"\\n### 현재 상태 기반 예측/최적화 사이클 실행 ###\")\n    current_oac_inlet_conditions = {oac_id: {'temp_c': 25.0, 'rh': 60.0} for oac_id in range(1, NUM_OACS + 1)}\n    current_fab_conditions = {\n        oac_id: {'temp_c_current': 23.0, 'rh_current': 50.0, 'temp_c_target': 22.0, 'rh_target': 45.0}\n        for oac_id in range(1, NUM_OACS + 1)\n    }\n    current_outside_conditions = {'temp_c': 30.0, 'rel_hum': 70.0} # 여름철 외기 조건 예시\n    current_chw_conditions = {'supply_temp_c': 7.0, 'return_temp_c': 12.0, 'dp_bar': 1.9, 'dpv_opening': 60.0}\n\n    final_system_outputs = run_complete_cycle_prediction_optimization(\n        current_oac_inlet_conditions, current_fab_conditions, current_outside_conditions,\n        current_chw_conditions, trained_models, OAC_AIR_FLOW_KG_S, CHILLER_SPECS\n    )\n\n    print(\"\\n--- 최종 시스템 출력 (요약) ---\")\n    if \"error\" in final_system_outputs:\n        print(f\"Error: {final_system_outputs['error']}\")\n    else:\n        print(f\"예측된 총 OAC 냉각 부하: {final_system_outputs.get('total_oac_cooling_load_kw_pred', 0):.2f} kW\")\n        print(f\"예측된 냉동기 총 부하: {final_system_outputs.get('chiller_total_load_rt_pred', 0):.2f} RT\")\n        optimal_op = final_system_outputs.get('optimal_chiller_operation', {})\n        print(f\"최적 냉동기 운영: {optimal_op.get('num_on',0)}대 가동, 예상 총 전력: {optimal_op.get('total_predicted_power_kw',0):.2f} kW\")\n        print(f\"  운영 메시지: {optimal_op.get('message', '')}\")","outputs":[],"execution_count":null,"metadata":{}}],"metadata":{"colab":{"from_bard":true},"kernelspec":{"display_name":"Python 3","name":"python3"}},"nbformat":4,"nbformat_minor":0}